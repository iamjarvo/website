<!DOCTYPE html>
<html dir="ltr" lang="en">

  <head>
    <title>Rubinius : Use Ruby&#8482;</title>
  	<meta charset="UTF-8">
  	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

    <meta content='en' http-equiv='content-language'>
    <meta content='Rubinius is an implementation of the Ruby programming language. The Rubinius bytecode virtual machine is written in C++. The bytecode compiler is written in pure Ruby. The vast majority of the core library is also written in Ruby, with some supporting primitives that interact with the VM directly.' name='description'>
    <link href='/' rel='home'>
    <link href='/' rel='start'>
    
    
    <link href='/feed/atom.xml' rel='alternate' type='application/atom+xml' title='Rubinius Blog' />
    <!--[if IE]><script src="http://html5shiv.googlecode.com/svn/trunk/html5.js" type="text/javascript"></script><![endif]-->
    <script src="/javascripts/jquery-1.3.2.js"></script>
    <script src="/javascripts/paging_keys.js"></script>
    
    <script src="/javascripts/application.js"></script>
    <style>article, aside, dialog, figure, footer, header, hgroup, menu, nav, section { display: block; }</style>

    <link href="/stylesheets/blueprint/screen.css" media="screen" rel="stylesheet" />
    <link href="/stylesheets/application.css"      media="screen" rel="stylesheet" />
    <link href="/stylesheets/blueprint/print.css"  media="print"  rel="stylesheet" />
    <!--[if IE]><link href="/stylesheets/blueprint/ie.css" media="screen" rel="stylesheet" type="text/css" /><![endif]-->
    <!--[if IE]><link href="/stylesheets/ie.css"           media="screen" rel="stylesheet" type="text/css" /><![endif]-->
    <link href="/stylesheets/pygments.css" media="screen" rel="stylesheet" />

    <link href="/favicon.ico"                 rel="shortcut icon"    type="image/vnd.microsoft.icon" />
    <link href="/images/apple-touch-icon.png" rel="apple-touch-icon" type="image/png" />
    <link href="/images/apple-touch-icon.png" rel="apple-touch-icon" type="image/png" sizes="72x72"   />
    <link href="/images/apple-touch-icon.png" rel="apple-touch-icon" type="image/png" sizes="114x114" />
  </head>

  <body>
    <div class='container'>
  <div class='span-21 blog_menu'>
    <header>
      <nav>
  <ul>
    <li><a href="/">Home</a></li>
    <li><a id="blog" href="/blog">Blog</a></li>
    <li><a id="documentation" href="/doc/en">Documentation</a></li>
    <li><a href="/projects">Projects</a></li>
    <li><a href="/roadmap">Roadmap</a></li>
    <li><a href="/releases">Releases</a></li>
  </ul>
</nav>

    </header>
  </div>

  <div class='span-3 last'>
  <div id='version'>
    <a href="/releases/1.2.4">1.2.4</a>
  </div>
</div>

</div>

    <div class="container posts_nav">
  <nav>
    <a href="/blog/posts_index">Index of Posts</a>
    <a id="feed_icon" href="/feed/atom.xml"><img alt="subscribe" src="/images/feed-icon16x16.png" /></a>
  </nav>
</div>

  <div class="container blog_posts">
  
    <div class="post">
      <h2 class="post_title">
        <a href="/2013/03/20/profiling-jitted-ruby-code-with-oprofile/" title="Profiling JIT-ted Ruby code with OProfile" class="post_title">
        Profiling JIT-ted Ruby code with OProfile
        </a>
      </h2>
      <div class="by_line">
  <p><span class="author">Ryo Onodera</span>
    <span class="date">20 March 2013</span>
    
      <a href="http://rubini.us/2013/03/20/profiling-jitted-ruby-code-with-oprofile/#disqus_thread" data-disqus-identifier="/2013/03/20/profiling-jitted-ruby-code-with-oprofile/"></a>

    
  </p>
</div>

      <p>You can now profile JIT-ted Ruby code!</p>

<p>Before:</p>

<pre><code>samples  %        linenr info                 app name                 symbol name
497      28.7117  instructions.cpp:82         rbx                      rubinius::MachineCode::interpreter(rubinius::State*, rubinius::MachineCode*, rubinius::InterpreterCallFrame*)
460      26.5742  (no location information)   anon (tgid:4118 range:0xb581c000-0xb589c000) anon (tgid:4118 range:0xb581c000-0xb589c000)
  # =&gt; The dark world of JIT-ted Ruby code
158       9.1277  jit_util.cpp:787            rbx                      rbx_set_local_depth
113       6.5280  block_environment.cpp:365   rbx                      rubinius::BlockEnvironment::call(rubinius::State*, rubinius::CallFrame*, rubinius::Arguments&amp;, int)
102       5.8925  (no location information)   rbx                      __x86.get_pc_thunk.bx
93        5.3726  jit_util.cpp:848            rbx                      rbx_push_local_depth
71        4.1017  variable_scope.cpp:108      rbx                      rubinius::VariableScope::set_local(int, rubinius::Object*)
68        3.9284  block_environment.cpp:62    rbx                      rubinius::BlockEnvironment::invoke(rubinius::State*, rubinius::CallFrame*, rubinius::BlockEnvironment*, rubinius::Arguments&amp;, rubinius::BlockInvocation&amp;)
52        3.0040  variable_scope.cpp:126      rbx                      rubinius::VariableScope::get_local(int)
47        2.7152  variable_scope.cpp:100      rbx                      rubinius::VariableScope::set_local(rubinius::State*, int, rubinius::Object*)
45        2.5997  kind_of.hpp:153             rbx                      bool rubinius::kind_of&lt;rubinius::Fiber&gt;(rubinius::Object const*)
24        1.3865  shared_state.cpp:295        rbx                      rubinius::SharedState::checkpoint(rubinius::ManagedThread*)
</code></pre>

<p>After:</p>

<pre><code>samples  %        linenr info                 app name                 symbol name
3468     27.0388  instructions.cpp:82         rbx                      rubinius::MachineCode::interpreter(rubinius::State*, rubinius::MachineCode*, rubinius::InterpreterCallFrame*)
3048     23.7642  loop.rb:7                   5060.jo                  _X_Object#forever$block@1
  # =&gt; Wow, the name of JIT-ted Ruby code is shown along side C++ function symbols!
1044      8.1397  jit_util.cpp:848            rbx                      rbx_push_local_depth
947       7.3834  (no location information)   rbx                      __x86.get_pc_thunk.bx
916       7.1417  jit_util.cpp:787            rbx                      rbx_set_local_depth
781       6.0892  block_environment.cpp:365   rbx                      rubinius::BlockEnvironment::call(rubinius::State*, rubinius::CallFrame*, rubinius::Arguments&amp;, int)
639       4.9821  block_environment.cpp:62    rbx                      rubinius::BlockEnvironment::invoke(rubinius::State*, rubinius::CallFrame*, rubinius::BlockEnvironment*, rubinius::Arguments&amp;, rubinius::BlockInvocation&amp;)
421       3.2824  variable_scope.cpp:108      rbx                      rubinius::VariableScope::set_local(int, rubinius::Object*)
389       3.0329  variable_scope.cpp:126      rbx                      rubinius::VariableScope::get_local(int)
326       2.5417  variable_scope.cpp:100      rbx                      rubinius::VariableScope::set_local(rubinius::State*, int, rubinius::Object*)
288       2.2454  shared_state.cpp:295        rbx                      rubinius::SharedState::checkpoint(rubinius::ManagedThread*)
283       2.2065  kind_of.hpp:153             rbx                      bool rubinius::kind_of&lt;rubinius::Fiber&gt;(rubinius::Object const*)
</code></pre>

<p>In short, you can tell how the machine code that the Rubinius JIT generates
performs.</p>

<p>Not satisfied yet? Even annotated profile is supported! That means you can even
know how much time it spends on each line of Ruby code or even on each CPU
instruction:</p>

<pre><code>/* 
 * Total samples for file : "/tmp/loop.rb"
 * 
 *   5658 19.9436
 */


   718  2.5308 :def increment(i)
   482  1.6990 :  i + 1
               :end
               :
               :def forever
               :  i = 0
  2933 10.3384 :  loop do /* _X_Object#forever$block@1 total:   6990 24.6387 */
  1525  5.3754 :    i = increment(i)
               :  end
               :end
               :
               :forever
</code></pre>

<p>We&rsquo;re using <a href="http://oprofile.sourceforge.net/news/">OProfile</a>, a profiling
software. In this blog post, I&rsquo;ll show you how to profile using it!</p>

<h3 id="whats-oprofile">What&rsquo;s OProfile?</h3>

<p>It&rsquo;s a very useful profiling tool available on Linux. It&rsquo;s a sampling-based
one. That means there is absolutely no change to Rubinius and your Ruby code to
profile. Just run it as you normally do. Also, the overhead of profiling is
minimal.</p>

<p>This is contrasted to measuring-based profiling. Rubinius&rsquo;s built-in profiler
and ruby-prof are both examples of measuring profilers. This means the overhead
is much bigger and can skew results because of that.</p>

<p>Basically, it works by reporting how many individual profiled items are sampled
compared to the overall total samples. It doesn&rsquo;t measure elapsed time. It&rsquo;s
much like top command&rsquo;s individual processes&rsquo; CPU % usage with far greater
flexibility. The actual profiled items can be any of C/C++ libraries, C/C++
functions, C/C++ source code lines, or CPU instructions.</p>

<p>So, OProfile can&rsquo;t usually profile Ruby code because it works on CPU
instruction level. From OProfile, it can&rsquo;t tell which Ruby source code line
Rubinius currently executing from the CPU instructions. However, it can profile
JIT-ted Ruby code because Rubinius compiles it very down into the CPU
instructions by definition.</p>

<p>OProfile works as a Linux kernel module. So, it&rsquo;s supported only for Linux.
Sadly, Ubuntu&rsquo;s OProfile and LLVM have bugs relating to this feature.
Apparently, there is no one using this. So you can say, we are really on the
cutting edge. ;)</p>

<p>Anyway, we must work around these problems. But how? There are a few options.
:)</p>

<h3 id="setup-ppa-the-super-simple-way-ubuntu-1210-only">Setup (PPA: the super simple way; Ubuntu 12.10 only)</h3>

<p>I prepared a <a href="https://launchpad.net/~ryoqun/+archive/ppa">PPA</a> just for you.
Add it to your system. To be specific, run this:</p>

<pre><code>$ sudo add-apt-repository ppa:ryoqun/ppa
$ sudo apt-get update
$ sudo apt-get install oprofile llvm-3.1
$ sudo apt-get dist-upgrade # Upgrade preinstalled libllvm3.1 to the PPA
</code></pre>

<p>By default, Rubinius doesn&rsquo;t use system-provided LLVM, so re-configure Rubinius
to use it and re-build Rubinius:</p>

<pre><code>$ cd /path/to/rubinius-git-repository
$ rake clean
$ ./configure --llvm-config llvm-config-3.1
$ rake
</code></pre>

<p>Done!</p>

<h3 id="setup-manual-build-the-hard-way">Setup (manual build: the hard way)</h3>

<p>If you really want to build LLVM and OProfile manually or if you&rsquo;re using an
other Linux distribution and the distribution doesn&rsquo;t provide OProfile-enabled
 LLVM packages, manually build LLVM and OProfile like this:</p>

<p>(I tested this on Ubuntu 12.10. Minor adjustments may be needed to build on
your environment)</p>

<p>Build and Install OProfile:</p>

<pre><code>$ sudo apt-get build-dep oprofile # do equivalent thing on your distro.
$ cd /path/to/working-dir-to-build-things
$ wget http://prdownloads.sourceforge.net/oprofile/oprofile-0.9.8.tar.gz
$ tar -xf oprofile-0.9.8.tar.gz
$ cd oprofile-0.9.8
$ ./autogen.sh
$ ./configure --prefix /usr # LLVM has a build issue. So install to /usr
$ make
$ sudo make install
$ adduser oprofile # this is needed for profiling JITted code
$ opreport --version
  # =&gt; opreport: oprofile 0.9.8 compiled on Mar  8 2013 00:57:08
</code></pre>

<p>Build LLVM with OProfile support enabled and rebuild Rubinius:</p>

<pre><code>$ sudo apt-get build-dep llvm # do equivalent thing on your distro.
$ cd /path/to/working-dir-to-build-things
$ wget http://llvm.org/releases/3.2/llvm-3.2.src.tar.gz
$ tar -xf llvm-3.2.src.tar.gz
$ cd llvm-3.2.src
$ ./configure --enable-optimized --disable-assertions --with-oprofile
$ make
$ sudo make install
</code></pre>

<p>If the compilation of <code>OProfileWrapper.cpp</code> fails like this:</p>

<pre><code>OProfileWrapper.cpp: In member function ‘bool llvm::OProfileWrapper::checkForOProfileProcEntry()’:
OProfileWrapper.cpp:141:62: error: ‘read’ was not declared in this scope
OProfileWrapper.cpp:142:24: error: ‘close’ was not declared in this scope
</code></pre>

<p>Apply this patch, then, re-<code>make</code> and continue:</p>

<pre><code>diff --git a/lib/ExecutionEngine/OProfileJIT/OProfileWrapper.cpp b/lib/ExecutionEngine/OProfileJIT/OProfileWrapper.cpp
index d67f537..7c0d395 100644
--- a/llvm-3.1-3.1/lib/ExecutionEngine/OProfileJIT/OProfileWrapper.cpp
+++ b/llvm-3.1-3.1/lib/ExecutionEngine/OProfileJIT/OProfileWrapper.cpp
@@ -29,6 +29,7 @@
 #include &lt;dirent.h&gt;
 #include &lt;sys/stat.h&gt;
 #include &lt;fcntl.h&gt;
+#include &lt;unistd.h&gt;
 
 namespace {
</code></pre>

<p>Phew, finally rebuild Rubinius!:</p>

<pre><code>$ cd /path/to/rubinius-git-repository
$ rake clean
$ rm -rf vendor/llvm # If you build Rubinius with vendorized LLVM.
$ ./configure
$ rake
</code></pre>

<h3 id="start-oprofile">Start OProfile</h3>

<p>OProfile can be configured by a command called <code>opcontrol</code>, not by a
configuration file, which are common.</p>

<pre><code>$ sudo opcontrol --deinit
$ sudo modprobe oprofile timer=1      # Needed only inside VirtualBox VMs
$ echo 0 | sudo tee /proc/sys/kernel/nmi_watchdog
$ sudo opcontrol --no-vmlinux
$ sudo opcontrol --separete all
$ sudo opcontrol --start
$ sudo opcontrol --dump               # Flushes buffered raw profile data
$ opreport --merge all --threshold 1  # Prints the report of profile
</code></pre>

<p>Setup is complete if you see an output from <code>opreport</code> like this:</p>

<pre><code>CPU: CPU with timer interrupt, speed 1858.39 MHz (estimated)
Profiling through timer interrupt
          TIMER:0|
  samples|      %|
------------------
    92127 67.6157 no-vmlinux
    21920 16.0880 rbx
     7950  5.8348 libc-2.15.so
     4068  2.9857 runner
     3429  2.5167 libstdc++.so.6.0.17
     2139  1.5699 cc1
     1416  1.0393 vm
</code></pre>

<p>Congratulations!</p>

<h3 id="run-ruby-code">Run Ruby code!</h3>

<p>To annotate Ruby code correctly, your current directory must be the top
directory of the Rubinius git repository:</p>

<pre><code>$ cd /path/to/rubinius-git-repository
$ ./bin/benchmark ./benchmark/core/hash/bench_access.rb
</code></pre>

<h3 id="generate-profile-report">Generate profile report</h3>

<p>Let&rsquo;s check the profile report of the above benchmark.</p>

<p>NOTE: try to run <code>opcontrol --dump</code> at least once while running Rubinius if
JIT-ted Ruby code doesn&rsquo;t show in the profile report. OProfile automatically
dumps periodically, but if your Ruby process terminates too quickly, you
should manually run <code>opcontrol --dump</code> while it&rsquo;s still alive.</p>

<pre><code>$ sudo opcontrol --dump &amp;&amp; sudo opjitconv /var/lib/oprofile/ 0 0
$ opreport --merge all --threshold 1 image:./bin/rbx --symbols --debug-info \
    &gt; /tmp/hash-access-symbols
$ opannotate --merge all --threshold 0.5 image:./bin/rbx --source \
    &gt; /tmp/hash-access-source
</code></pre>

<p>I&rsquo;ll omit but you can generate profile report of annotated assembly by passing
<code>--assembly</code> to <code>opannotate</code> instead of <code>--source</code>.</p>

<h3 id="reset-current-profile">Reset current profile</h3>

<p>By default, OProfile keeps the profile data indefinitely. To reset it, run
this:</p>

<pre><code>$ sudo opcontrol --reset
</code></pre>

<h3 id="how-to-read-the-profile-result">How to read the profile result</h3>

<p>Open <code>/tmp/hash-access-symbols</code>, the content should be like this:</p>

<pre><code>CPU: CPU with timer interrupt, speed 1860.42 MHz (estimated)
Profiling through timer interrupt
samples  %        linenr info                 app name                 symbol name
3571     31.5990  (no location information)   no-vmlinux               /no-vmlinux
619       5.4774  bench_access.rb:16          8295.jo                  _X_Object#__block__$block@7
599       5.3004  bench_access.rb:24          8295.jo                  _X_Object#__block__$block@11
531       4.6987  bench_access.rb:8           8295.jo                  _X_Object#__block__$block@1
457       4.0439  (no location information)   rbx                      __x86.get_pc_thunk.bx
318       2.8139  jit_util.cpp:787            rbx                      rbx_set_local_depth
298       2.6369  bench_access.rb:42          8295.jo                  _X_Object#__block__$block@20
277       2.4511  object.cpp:362              rbx                      rubinius::Object::hash(rubinius::State*)
236       2.0883  jit_primitives.cpp:4494     rbx                      jit_stub_object_hash
236       2.0883  tuple.cpp:36                rbx                      rubinius::Tuple::put(rubinius::State*, int, rubinius::Object*)
222       1.9644  inline_cache.cpp:696        rbx                      rubinius::InlineCache::check_cache_poly(rubinius::State*, rubinius::InlineCache*, rubinius::CallFrame*, rubinius::Arguments&amp;)
197       1.7432  jit_util.cpp:848            rbx                      rbx_push_local_depth
187       1.6547  variable_scope.cpp:126      rbx                      rubinius::VariableScope::get_local(int)
179       1.5839  compiledcode.cpp:212        rbx                      rubinius::CompiledCode::specialized_executor(rubinius::State*, rubinius::CallFrame*, rubinius::Executable*, rubinius::Module*, rubinius::Arguments&amp;)
162       1.4335  hash.rb:220                 8295.jo                  _X_Hash#key_index@15
147       1.3008  hash.rb:325                 8295.jo                  _X_Hash#values_at$block@13
143       1.2654  object.cpp:400              rbx                      rubinius::Object::hash_prim(rubinius::State*)
137       1.2123  (no location information)   libc-2.15.so             /lib/i386-linux-gnu/libc-2.15.so
127       1.1238  variable_scope.cpp:100      rbx                      rubinius::VariableScope::set_local(rubinius::State*, int, rubinius::Object*)
111       0.9822  inline_cache.cpp:576        rbx                      rubinius::InlineCache::check_cache_reference(rubinius::State*, rubinius::InlineCache*, rubinius::CallFrame*, rubinius::Arguments&amp;)
108       0.9557  vm.cpp:175                  rbx                      rubinius::VM::new_object_typed_dirty(rubinius::Class*, unsigned int, rubinius::object_type)
99        0.8760  vm.cpp:207                  rbx                      rubinius::VM::new_young_tuple_dirty(unsigned int)
97        0.8583  array18.rb:6                8295.jo                  _X_Array#map@12
93        0.8229  integer.cpp:84              rbx                      rubinius::Integer::from(rubinius::State*, int)
90        0.7964  hash.rb:137                 8295.jo                  _X_Hash#[]@23
76        0.6725  array.cpp:205               rbx                      rubinius::Array::set(rubinius::State*, int, rubinius::Object*)
72        0.6371  linkedlist.cpp:27           rbx                      LinkedList::remove(LinkedList::Node*)
68        0.6017  tuple.cpp:64                rbx                      rubinius::Tuple::create(rubinius::State*, int)
57        0.5044  method_primitives.cpp:12327 rbx                      rubinius::Primitives::object_hash(rubinius::State*, rubinius::CallFrame*, rubinius::Executable*, rubinius::Module*, rubinius::Arguments&amp;)
</code></pre>

<p>As you can guess, symbol names beginning with <code>_X_</code> is the JIT-ted Ruby code.
Many Ruby benchmark blocks are JIT-ted (like
<code>_X_Object#__block__$block@7</code> at <code>bench_access.rb:16</code>) and listed near the top.
Also, <code>_X_Array#map@12</code> is a JIT-ted code of <code>Array#map</code>. I&rsquo;ll explain the
format of the report using it as an example:</p>

<pre><code>97        0.8583  array18.rb:6                8295.jo                  _X_Array#map@12
</code></pre>

<p><code>97</code> is the number of counts OProfile found what Rubinius was executing, while
periodically sampling it.</p>

<p><code>0.8583</code> is the percentage to the total number of samples OProfile collected.
Note that summing all entries up doesn&rsquo;t equal to 100%, because <code>opreport</code> only
reported the top part of whole profile result (by <code>--threshold 0.5</code>).</p>

<p><a href="https://github.com/rubinius/rubinius/blob/1d7d7b2e2880478776476089d4dd93fd97aff122/kernel/bootstrap/array18.rb#L6"><code>array18.rb:6</code></a>
is the source location where this method is defined (this is same as
<code>Method#source_location</code>).</p>

<p><code>8295.jo</code> is a special <code>app name</code> for JIT-ted code. Usually <code>app name</code> is the
name of file C/C++ functions reside in (shared libraries or executables).
So, for normal Rubinius&rsquo; C++ functions, <code>app name</code> is just <code>rbx</code> because they
reside in <code>./bin/rbx</code>. For JIT-ted Ruby code, there can be no meaningful <code>app
name</code>, because JIT-ted Ruby code is generated at runtime and they reside in no
file, but only in memory. So, OProfile uses <code>*.jo</code> as <code>app name</code> in such cases.
And, <code>8295</code> means this is profiled when running the process of PID 8295.</p>

<p><code>_X_Array#map@12</code> is the name of symbol for this entry of profile report
(duh!).</p>

<p>Open <code>/tmp/hash-access-source</code>, the content should be like this (I&rsquo;ll omit some
unimportant part, because this file is big):</p>

<pre><code>/* 
 * Total samples for file : "kernel/common/hash18.rb"
 * 
 *   4870 12.8904
 */

&lt;credited to line zero&gt;     19  0.0503 :
               :# -*- encoding: us-ascii -*-
               :
               :class Hash
               :
               :  include Enumerable
               :
...
               :
               :  class Bucket
               :    attr_accessor :key
               :
   633  1.6755 :    def match?(key, key_hash) /* _X_Hash::Bucket#match?@16     75  0.1985, _X_Hash::Bucket#match?@16     45  0.1191, total:    120  0.3176 */
    40  0.1059 :      case key
   218  0.5770 :      when Symbol, Fixnum
   319  0.8444 :        return key.equal?(@key)
               :      end
               :
               :      @key_hash == key_hash and (Rubinius::Type::object_equal(key, @key) or key.eql?(@key))
               :    end
               :  end
...
               :end
...
</code></pre>

<p>You might wonder why <code>Hash::Bucket#match?</code> has so many counts while this didn&rsquo;t
appear in the report for symbols. The reason is that the method is inlined to
each its callers (maybe many top-appearing JIT-ted Ruby blocks). How cool this
is! You can really know which Ruby code is actually taking too much time.</p>

<h3 id="my-last-favor">My last favor</h3>

<p>I wish the official Ubuntu packages are fixed and there is no need to add any
PPA. I want it-just-works. I reported affecting bugs to Ubuntu&rsquo;s bug tracking
system. So, please vote it up for fixing (vote them with &ldquo;affects you?&rdquo;,
please!!):</p>

<ul>
  <li><a href="https://launchpad.net/bugs/1154025">Bug 1154025</a> Install PIC version of libbfd.a</li>
  <li><a href="https://launchpad.net/bugs/1148682">Bug 1148682</a> symbol lookup error: /usr/lib/libopagent.so: undefined symbol: bfd_init</li>
  <li><a href="https://launchpad.net/bugs/1148529">Bug 1148529</a> OProfile support is disabled</li>
</ul>

<h3 id="further-profiling">Further profiling</h3>

<p>There is new profiling tool on Linux: <code>perf</code> and <code>operf</code> (OProfile&rsquo;s new
command). I don&rsquo;t know them well, but certainly they will be useful for
profiling Rubinius.</p>

<p>As a last note, this is partially based on <a href="http://code.google.com/p/unladen-swallow/wiki/UsingOProfile">Unladen Swallow&rsquo;s
information</a>
of profiling LLVM-based JIT-ted code by OProfile.</p>

<p>Happy profiling!</p>

    </div>
  
    <div class="post">
      <h2 class="post_title">
        <a href="/2013/03/19/pdx-summit-recap/" title="PDX Summit Recap" class="post_title">
        PDX Summit Recap
        </a>
      </h2>
      <div class="by_line">
  <p><span class="author">Brian Shirai</span>
    <span class="date">19 March 2013</span>
    
      <a href="http://rubini.us/2013/03/19/pdx-summit-recap/#disqus_thread" data-disqus-identifier="/2013/03/19/pdx-summit-recap/"></a>

    
  </p>
</div>

      <p>Last week, Dirkjan spent the week with me at the Engine Yard office in
Portland, OR. We wanted to discuss a variety of topics related to Rubinius
technology. We started the week by making the following list:</p>

<ul>
  <li>Inline cache</li>
  <li>JIT IR</li>
  <li>Performance of JIT&rsquo;d code</li>
  <li>Extension API</li>
  <li>Concurrency and garbage collection</li>
</ul>

<p>We spent the week mostly writing a ton of things on the whiteboard, discussing
them, erasing them, and writing a bunch more. Ultimately, we touched on all
the topics but we did not get to discussing the extension API in depth, so
we&rsquo;ll skip that one for now. I&rsquo;ve <a href="http://rubini.us/2013/03/13/welcome-dirkjan/">previously
blogged</a> about our inline cache
discussion. Here I&rsquo;ll summarize the rest of our discussions.</p>

<h2 id="just-in-time-compiler">Just-in-time Compiler</h2>

<p>The just-in-time (JIT) compiler that converts our virtual machine bytecode to
machine code is a fundamental part of making Ruby fast. It is also one of the
most complex components of Rubinius. It requires interfacing with the virtual
machine to get runtime data and coordinating with the garbage collector to
keep other runtime data structures consistent.</p>

<p>We are able to leverage <a href="http://llvm.org">LLVM</a> for especially difficult parts
of machine code generation, like instruction selection, instruction scheduling
and register allocation. However, the semantics of Ruby are so removed from
those of the underlying CPU that we have a lot of work we still need to do to
improve the quality of the machine code.</p>

<p>One important component of this work is the ability to represent operations
that have Ruby semantics (but are not part of Ruby itself) in a way that we
can perform transformations on those operations. The &ldquo;not part of Ruby&rdquo; is
actually a bit fuzzy. The concept of object allocation is certainly a part of
Ruby. But the specific operation of reserving a region in the heap is
invisible to Ruby.</p>

<p>There are a couple operations in particular that are critical to Ruby
performance, especially when emitting machine code from the JIT. Those
operations are type guards and object allocation. If our assumptions for the
particular type of a value hold, we want to emit the fewest number of guards
as possible and we want the largest contiguous sequence of machine
instructions that are valid under a specific guard.</p>

<p>Likewise, if an object is allocated but does not get passed outside of the
code sequence we are compiling to machine code, and we can see there are no
other side effects, we may be able to avoid allocating the object. A good
example of this in Rubinius, where the core library is implemented in Ruby, is
the ByteArray object that is used by String. A ByteArray is a fixed vector of
8-bit bytes. If an intermediate operation on a String creates a ByteArray and
that object isn&rsquo;t used outside the JIT&rsquo;d method, the JIT should be able to see
through the object creation and recognize that just some machine bytes are
being moved around or transformed. The ByteArray allocation can be elided.</p>

<p>These two examples, type guards and object allocation, are just a couple
things we expect the JIT to do well. There are many others.</p>

<p>Right now, our JIT converts the virtual machine bytecode directly into LLVM
IR. To support more sophisticated JIT transformations, we need a
representation in between bytecode and LLVM IR, which is one of the things we
will be working on.</p>

<p>Another aspect of the JIT that needs an overhauls is the infrastructure around
running the JIT. It runs on a separate native thread with few synchronization
points. Since Rubinius has no global lock, and since we need a variety of
auxiliary threads for system operations (e.g. handling process signals,
running object finalizers, handling debugger events), we have some
infrastructure for handling the lifetimes of these auxiliary threads. This is
a particularly complicated aspect of Rubinius because when Ruby code calls
<code>fork()</code> or <code>exec()</code>, the Ruby code knows nothing about these auxiliary
threads. We have to be careful that state is maintained across these calls.
This component will be enhanced to better handle auxiliary threads that are
actually proper Ruby threads (all auxiliary threads are fundamentally Ruby
threads but not necessarily visible in Ruby). This will permit us to have
multiple, potentially completely different, JIT threads running
simultaneously.</p>

<h2 id="performance">Performance</h2>

<p>For us as people, when our assumptions fail we often just blunder on making
fools of ourselves. Too bad we don&rsquo;t have a &ldquo;check your assumptions&rdquo; mode as
useful as the one we build into the JIT. In the JIT, if our assumptions fail
and we don&rsquo;t catch it, we&rsquo;re going to compute the wrong values or cause the
wrong actions to be performed.</p>

<p>So, in the JIT, when our assumptions are wrong, we must change course. This
course change may be to go down a different path in the machine code or to
exit the machine code entirely and go back to the interpreter. Both paths have
significant performance implications.</p>

<p>A reason to exit the machine code is that one significant aspect of generating
fast machine code is proper use of the type guards. If our assumptions about
the type of a value are wrong, simply exiting back to the interpreter means
that we don&rsquo;t pollute the LLVM IR with types that can inhibit LLVM
optimizations from being as effective. On the other hand, there are runtime
costs associated with both exiting to the interpreter and running the
interpreter instead of machine code. Also, if we exit the generate machine code
too often, we may trigger a de-opt, throwing away that version of the machine
code and requiring the JIT to create a new one.</p>

<p>Another aspect of the performance of the machine code we emit is how we handle
virtual machine operations. Some aspects of running Ruby require very
low-level operations that we call primitives. These are coded in C++ and
interact with internal virtual machine facilities. When compiling machine
code, we want as few conditionals and as few function calls as possible to get
the highest performance. Typically, we call a function that performs the
primitive operation and then returns to the JIT&rsquo;d machine code. As we move
more and more things into Ruby itself, it is possible for the JIT to inline
operations and get the greatest possible optimizations. This is another area
we will be working on as we improve the JIT.</p>

<h2 id="concurrency">Concurrency</h2>

<p>One of the goals for Rubinius since the very beginning is to provide excellent
support for concurrency and parallelism in Ruby. We have already removed the
global interpreter lock (GIL/GVL) from Rubinius. However, we have to ensure
that we don&rsquo;t replace it with an effective global lock when we implement
components of the system.</p>

<p>The key to improving lock-freedom throughout the system is to use less locks.
That may seem obvious, but it is not necessarily that simple. As I mentioned
above, the virtual machine actually uses a variety of threads internally. And
with no global lock, any Ruby thread could invoke any virtual machine
operation, like <code>fork()</code>, at any time. Multiple Ruby threads could be calling
the same method on the same object at the same time. Considering my previous
post about inline caches, this implies that all sorts of data races and
concurrency bugs could arise just from calling Ruby methods.</p>

<p>In the virtual machine, we must be careful to ensure correctness under
concurrent execution. The classical way of doing so is to use locking.
However, there is tons of research from the &rsquo;90s about lock-free and wait-free
algorithms. This academic research is slowly trickling down to industry in
various domains. We will be using lock-free implementations of various virtual
machine data structures to improve support for concurrency and parallelism.</p>

<h2 id="garbage-collection">Garbage Collection</h2>

<p>One particularly challenging area that requires careful control of concurrency
is the garbage collector. Rubinius provides a generational garbage collector
with very short pause times when collecting the young generation. The
generational architecture allows us to only collect a small region of the heap
instead of the whole heap every time. We also support object allocation using
thread-local buffers to avoid locking and contention when Ruby code is running
in parallel.</p>

<p>However, the garbage collector architecture pauses all threads to perform a
collection. While the pause for a young generation collection is on the order
of a few milliseconds (5-15 in many cases), there is the overhead of forcing
all the various threads to pause.</p>

<p>There is only one way to address this issue and that is to make the garbage
collector concurrent. Fortunately, we can achieve this with some modifications
to our existing garbage collector. When adding concurrency to the garbage
collector, we want to avoid slowing down non-garbage-collector operations,
typically referred to as mutator performance. (Operations in the system can be
viewed as partitioned into two sets: the heap management&ndash;allocation and
garbage collection, and the operations that mutate the heap&ndash;mutator
operations.)</p>

<p>With modifications to our mature generation collector (based on the Immix
collector), we can perform partial heap collections and preserve the
generational benefits while also limiting stop-the-world pauses to specific
regions of the heap and bounding the pause times.</p>

<h2 id="semantic-versioning">Semantic Versioning</h2>

<p><a href="http://semver.org/">Semantic Versioning</a> is a methodology for versioning
software to support correct dependency management. MRI has never had
particularly strong support for versioning, with semantic changes being added
in patch levels (not even visible in the RUBY_VERSION constant) and major
version increments on special dates completely devoid of semantic relevance.</p>

<p>In Rubinius, we would like to provide a more sound versioning discipline, in
particular, semantic versioning. However, this raises some significant
challenges. Let&rsquo;s consider some of the components of Rubinius:</p>

<ul>
  <li>Ruby language itself in one of three language modes: 1.8, 1.9, and 2.0</li>
  <li>Ruby core classes</li>
  <li>Ruby standard library</li>
  <li>MRI compatibility &ldquo;C-API&rdquo; for supporting C-extensions</li>
  <li>Supporting core classes like ByteArray and Tuple</li>
  <li>Bytecode compiler</li>
  <li>Virtual machine instruction set</li>
  <li>Internal APIs for JIT, garbage collection, concurrency management</li>
</ul>

<p>The key component on which semantic versioning is based is the public API. But
what is included in that? Is it just Ruby as covered in RubySpec? Is it also
our supporting Ruby classes or Ruby facilities like the parser and bytecode
compiler? Since Rubinius is a language platform used to implement other
programming languages besides Ruby, resolving these questions correctly is
important.</p>

<p>Along with a sound versioning discipline, we also want to promote continuous
delivery of enhancements to Rubinius. Technically, these are compatible goals,
but require that we consider how to organize our development and source
branches when we create backward-incompatible API changes.</p>

<p>As we work toward the Rubinius 2.0 release, we will do our best to implement
semantic versioning. You can help us by testing your applications, gems, or
libraries on Rubinius. One great place to do this, of course, is <a href="https://travis-ci.org/">Travis
CI</a>.</p>

<h2 id="all-work-and-no-play">All Work and No Play</h2>

<p>Portland is a beautiful city. It&rsquo;s not very big but has enough city things to
feel like a proper city. I didn&rsquo;t want to keep Dirkjan caged in the office all
day every day, so when the weather looked promising on Friday, we packed our
concurrency and garbage collection conversation up and headed out. First we
went to <a href="http://www.pdx.edu/">Portland State University</a> to attend a talk at a
programming language club. The talk was on continuation-passing style,
defunctionalization, and transformations. It was somewhat related to our
compiler work and it was certainly interesting. But my real motive was to
introduce Dirkjan to my former coworker <a href="https://twitter.com/larrytheliquid">Larry
Diehl</a>, who is a PhD student at PSU doing
fascinating work in dependently typed programming language theory.</p>

<p>After the talk at PSU, we hopped on the MAX light rail and headed toward the
<a href="http://japanesegarden.com/">Japanese Garden</a>. The bus that would take us the
rest of the way wasn&rsquo;t due for 25 minutes so we decided to walk. The garden is
located in Portland&rsquo;s <a href="http://washingtonparkpdx.org/">Washington Park</a>, which
is located in the west hills of Portland. So, we walked, uphill, for quite a
while. We walked past the Lewis and Clark monument, through the <a href="http://www.rosegardenstore.org/">international
rose garden</a>, past the tennis courts and
finally up another steep hill to the Japanese Garden.</p>

<p>The Japanese Garden is one of the most beautiful and authentic outside of
Japan. We are very lucky to have it here and my wife and I visit it frequently
to enjoy the beautiful views and bask in the tranquility. Since it is early
spring, not many plants were blossoming yet, but we saw some huge koi, some
water falls, beautiful trees, and a stunning view of Portland. Unfortunately,
Mt Hood was hiding in the clouds that day.</p>

<p>I&rsquo;m not much of a photographer, but here are some pics from the trip.</p>

<p><img src="http://farm9.staticflickr.com/8516/8573161804_69e037f173_c.jpg" alt="Dirkjan photographing from a bridge" />
<img src="http://farm9.staticflickr.com/8367/8573160544_466e14d2ec_c.jpg" alt="Koi!" />
<img src="http://farm9.staticflickr.com/8378/8572067073_a0555e44bd_c.jpg" alt="Plants!" /></p>

    </div>
  
    <div class="post">
      <h2 class="post_title">
        <a href="/2013/03/13/welcome-dirkjan/" title="Welcome Dirkjan!" class="post_title">
        Welcome Dirkjan!
        </a>
      </h2>
      <div class="by_line">
  <p><span class="author">Brian Shirai</span>
    <span class="date">13 March 2013</span>
    
      <a href="http://rubini.us/2013/03/13/welcome-dirkjan/#disqus_thread" data-disqus-identifier="/2013/03/13/welcome-dirkjan/"></a>

    
  </p>
</div>

      <p>I am excited to announce that <a href="https://engineyard.com">Engine Yard</a> is
sponsoring <a href="https://github.com/dbussink">Dirkjan Bussink</a> to work on Rubinius!</p>

<p>A long time ago (around 2008) when Dirkjan first showed up in the Rubinius
project he was still a university student finishing his Masters degree. He let
me read a draft of his thesis on brain-computer interfaces. Dirkjan has been
helping out on Rubinius since then. Recently, he&rsquo;s been fixing concurrency,
garbage collection, and JIT issues.</p>

<p>This week, Dirkjan is working from the Engine Yard office in Portland, OR.
We&rsquo;ve got a list of topics that we&rsquo;re delving into to get ready for several
technology improvements in Rubinius. We started with a list of five things,
one for each day. Unfortunately, time always goes faster than we expect so
we&rsquo;ve dropped one topic. I&rsquo;ll blog a summary of our discussions so you get an
idea of some of the big stuff coming in Rubinius.</p>

<p>Our first discussion was about our inline cache mechanisms. An inline cache is
used at a method call location to speed up calling a method. The first time it
is called, the method is looked up. Subsequently, as long as the receiver is
the correct type, the same method can safely be used. This is a typical
execution-time versus memory size trade-off. We cache the method we found,
which saves time looking it up again at the expense of some additional memory
to store the method. As with all caches, we have to carefully consider cache
invalidation.  Let&rsquo;s use a quick code sample to illustrate the inline cache.</p>

<div class="highlight"><pre><code class="ruby"><span class="lineno">1</span> <span class="k">class</span> <span class="nc">A</span>
<span class="lineno">2</span>   <span class="k">def</span> <span class="nf">a</span>
<span class="lineno">3</span>   <span class="k">end</span>
<span class="lineno">4</span> <span class="k">end</span>
<span class="lineno">5</span> 
<span class="lineno">6</span> <span class="k">class</span> <span class="nc">B</span> <span class="o">&lt;</span> <span class="n">A</span>
<span class="lineno">7</span> <span class="k">end</span>
</code></pre>
</div>

<p>In the example above, the class <code>B</code> inherits from <code>A</code>, which provides the method
<code>a</code>. If we call <code>a</code> on an instance of <code>B</code>, we look up the method and find it
in <code>A</code>.</p>

<div class="highlight"><pre><code class="ruby"><span class="lineno">1</span> <span class="n">b</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">new</span>
<span class="lineno">2</span> <span class="n">b</span><span class="o">.</span><span class="n">a</span>
</code></pre>
</div>

<p>Here, in the code representation for the call <code>b.a</code>, we store an inline cache
object. As long as the type of object we see in <code>b</code> is the same, we can safely
call the cached method <code>a</code>. However, if the type of <code>b</code> changes, for example,
because we define a method <code>a</code> on class <code>B</code> itself, we must invalidate the
cache and look up the method again.</p>

<p>The inline cache can be very important for the speed of the virtual machine
executing Ruby code. However, the inline cache is also very important for our
just-in-time (JIT) compiler that generates machine code, completely avoiding
the VM interpreter. Since the inline cache records the types of the Ruby
objects seen at the call site, we can use that information in the JIT to
generate fast code as long as our assumptions about the object type are
correct.</p>

<p>Since inline caches are so important, Dirkjan and I did a complete review of
our existing inline caching and analyzed how to improve it. The most important
thing for improving execution speed is to do less. And the best way to do less
is to reduce redundancy.</p>

<p>We started our analysis with an enumeration of all the kinds of calls that we
see in Ruby. This is the list that we made:</p>

<ul>
  <li>fixed-arity method send</li>
  <li>variadic method send</li>
  <li><code>respond_to?</code></li>
  <li><code>kind_of?</code></li>
  <li>fixed-arity <code>a.send</code></li>
  <li>variadic <code>a.send</code></li>
  <li><code>super</code> with explicit arguments</li>
  <li><code>super</code> with implicit arguments</li>
  <li><code>method_missing</code></li>
</ul>

<p>This list is all kinds of method sends that you can see directly in Ruby code.
We added to this list a few other things that are not in Ruby code:</p>

<ul>
  <li>extension API calls</li>
  <li>method combinations like <code>A.new</code> which reduces to <code>A.allocate.initialize</code></li>
  <li>call_custom (a special Rubinius instruction)</li>
  <li>primitives (parts of Ruby functionality that must be implemented in the VM)</li>
</ul>

<p>The next thing we did was look at the method call sites from the perspective
of the virtual machine. Certain method calls, like <code>respond_to?</code> imply certain
VM operations. This perspective is very important. Sometimes people complain
that Ruby is too dynamic because you could, for example, alias <code>respond_to?</code>
or <code>eval</code> to some other name. Now any attempt to statically analyze Ruby fails
because you can&rsquo;t know ahead of time what the alias may be. This is actually
not an issue if you consider the perspective from the VM. No matter what the
method name is, the ultimate VM operation for looking up a method will
execute. By associating method call sites with a VM operation, we get more
insight into how best to structure the inline cache.</p>

<p>The next part of our analysis involved looking at what values are stored in
the inline cache for the various types we enumerated, and what values are used
for cache invalidation. The purpose of this analysis is two-fold: correctness
and performance. We want to ensure that our cache invalidation is correct
but also not generating false positives (i.e. invalidating cases that are not
actually invalid). We also want to ensure that storing and updating the data
in the cache can be done efficiently.</p>

<p>The final part of our analysis concerned the cardinality of the cache. In
object-oriented code, a method call site may be <em>monomorphic</em> (only one type
is seen), <em>polymorphic</em> (a small number of different types are seen), or
<em>megamorphic</em> (a huge number of different types are seen). This perspective
can be very important for performance and for memory overhead. We don&rsquo;t want
to waste memory for sites that are monomorphic. Nor do we want the cache to be
thrashing when many different types are seen.</p>

<p>In summary, we looked at these aspects of inline caches: method call site
types, VM operations that result from the method call, the kind of data cached
and cache invalidation, and the cardinality of the method call site. We&rsquo;ll be
taking the results of our discussion and implementing changes to our inline
caching over the next few weeks.</p>

<p>If you get a chance, pop into the #rubinius IRC channel on freenode.net and
say hello to Dirkjan!</p>

    </div>
  
    <div class="post">
      <h2 class="post_title">
        <a href="/2013/02/26/heroku-cedar-rubinius-2-puma-2-in-three-easy-steps/" title="Heroku (Cedar) + Rubinius 2 + Puma 2 in Three Easy Steps" class="post_title">
        Heroku (Cedar) + Rubinius 2 + Puma 2 in Three Easy Steps
        </a>
      </h2>
      <div class="by_line">
  <p><span class="author">Shane Becker</span>
    <span class="date">26 February 2013</span>
    
      <a href="http://rubini.us/2013/02/26/heroku-cedar-rubinius-2-puma-2-in-three-easy-steps/#disqus_thread" data-disqus-identifier="/2013/02/26/heroku-cedar-rubinius-2-puma-2-in-three-easy-steps/"></a>

    
  </p>
</div>

      <h3 id="tldr">tl;dr</h3>

<p>It&rsquo;s now <strong><a href="https://github.com/rubinius/heroku-rbx-puma-rails-app">very easy</a></strong> to get a <a href="https://devcenter.heroku.com/articles/rails3">Rails app</a> on <a href="https://devcenter.heroku.com/articles/cedar">Heroku&rsquo;s Cedar Stack</a> running on <a href="http://rubini.us" title="Rubinius : Use Ruby&#8482;">Rubinius 2.0</a> and <a href="http://puma.io" title="A Modern, Concurrent Web Server for Ruby - Puma">Puma 2.0</a>.</p>

<h3 id="the-backstory">The Backstory</h3>

<p>The fine folks at Heroku have been adding support for using <a href="http://gembundler.com" title="Bundler: The best way to manage a Ruby application's gems">Bundler</a> to <a href="https://devcenter.heroku.com/articles/ruby-versions">specify which version of Ruby</a> your app uses and even <a href="https://blog.heroku.com/archives/2012/12/13/run_jruby_on_heroku_right_now">to specify which Ruby</a> it uses.</p>

<p>I&rsquo;ve checked in on the progress of using Rubinius with this same method every couple few months for the past year or so. I was always met with the same results&hellip; <q>&ldquo;not quite yet, we&rsquo;re working on it&rdquo;</q>.</p>

<p>Last night I was getting mentally packed for <a href="https://waza.heroku.com/2013">Waza</a> later this week and decided to check in on the state of things so I could ask the right people the right questions in person when we&rsquo;re all together. Turns out that sometime between last time and this time, they&rsquo;ve got things working. Boom diggity! And it&rsquo;s pretty ding-dang easy too! Double boom diggity!</p>

<h3 id="the-build-up">The Build Up</h3>

<p>I&rsquo;m going to assume that if you want to use Rubinius 2.0 that you also have the good sense to want to use Puma 2.0. There are three very simple steps to get up and running with Rubinius 2.0 + Puma 2.0.</p>

<h4 id="step-1">Step 1</h4>

<p>Add the Puma gem to your <code>Gemfile</code>.</p>

<script src="https://gist.github.com/veganstraightedge/5041441.js"></script>

<h4 id="step-2">Step 2</h4>

<p>Tell Heroku to use Puma as your web server in your <code>Procfile</code>.</p>

<script src="https://gist.github.com/veganstraightedge/0135a61335bc76b1d9d5.js"></script>

<h4 id="step-3">Step 3</h4>

<p>Specify Rubinius as your Ruby engine in your <code>Gemfile</code>.</p>

<script src="https://gist.github.com/veganstraightedge/1fb7ff88e74567c6e2e6.js"></script>

<h3 id="the-breakdown">The Breakdown</h3>

<p>Once you&rsquo;ve done those things, your workflow is the same as before.
<code>bundle update &amp;&amp; git commit -am "Double boom diggity!" &amp;&amp; git push heroku master</code></p>

<p>If you&rsquo;re changing an existing app from Heroku&rsquo;s default Ruby (MRI 1.9.x) to Rubinius, you&rsquo;ll see a message like this when you <code>git push heroku master</code>.</p>

<script src="https://gist.github.com/veganstraightedge/5041986.js"></script>

<p>The important lines are <code>Old: ruby 1.9.3</code> and <code>New: rubinius 2.0.0.rc1</code>. After that, everything the same as before. The bundling starts, etc.</p>

<h3 id="the-outro">The Outro</h3>

<p>That&rsquo;s it. You should now be up and running with Rubinius and Puma!</p>

<p>If you have problems, say something in the comments with a link to a gist with your problem output. If you succeed and get up and running in production, let us in the comments too. Tell the world that you love Rubinius/Puma.</p>

<p>I threw together this <a href="https://github.com/rubinius/heroku-rbx-puma-rails-app">quick and dirty Rails app</a> from scratch deployed to Heroku to show all this in action. <a href="http://heroku-rbx-puma-rails-app.herokuapp.com" title="Using Rubinius &amp; Puma on Heroku">http://heroku-rbx-puma-rails-app.herokuapp.com</a>. I also migrated an existing MRI 1.9.3 app ( <a href="http://farmhouse.la" title="The Farmhouse in Hollywood, California">The Farmhouse site</a> ) to Rubinius 2.0 to show the migration is easy too.</p>

<h3 id="the-thank-yous">The Thank Yous</h3>

<p>None of this would be possible without the hard work of <a href="https://github.com/carllerche">Carl Lerche</a>, <a href="https://github.com/wycats/">Yehuda Katz</a>, <a href="https://github.com/indirect/">André Arko</a>, <a href="https://github.com/hone">Terrence Lee</a> and the other contributors to <a href="https://github.com/carlhuda/bundler">Bundler</a>. And a special thanks to Terrence Lee for his dutiful stewardship of the <a href="https://github.com/heroku/heroku-buildpack-ruby/">Heroku Ruby Buildpack</a>. Once again, the awesome powers of Open Source make great things possible.</p>

<h3 id="the-footnotes">The Footnotes</h3>

<p>As of this writing &ldquo;Rubinius 2.0&rdquo; actually means &ldquo;Rubinius 2.0.0.dev&rdquo; and &ldquo;Puma 2.0&rdquo; actually means &ldquo;Puma 2.0.0b6&rdquo;. The net result is the same though.</p>


    </div>
  
    <div class="post">
      <h2 class="post_title">
        <a href="/2012/01/04/debugging-rubinius/" title="Debugging scary crashes of Rubinius" class="post_title">
        Debugging scary crashes of Rubinius
        </a>
      </h2>
      <div class="by_line">
  <p><span class="author">Dirkjan Bussink</span>
    <span class="date">04 January 2012</span>
    
      <a href="http://rubini.us/2012/01/04/debugging-rubinius/#disqus_thread" data-disqus-identifier="/2012/01/04/debugging-rubinius/"></a>

    
  </p>
</div>

      <p>Bugs, we all are in the infinite fight of getting rid of them. Sometimes
they are trivial, other times a bit harder. In this video I&rsquo;m going to
show how I have been debugging an issue that caused memory corruption of
your dear Ruby objects in Rubinius.</p>

<h3 id="background">Background</h3>

<p>It&rsquo;s a pretty long video clocking at 55 minutes but I&rsquo;m trying to be
detailed in the discovery process. I&rsquo;m explaining the steps I&rsquo;m taking
along the way and explaining why I&rsquo;m taking those.</p>

<p>The real debugging process if of course littered with taking wrong turns
so please don&rsquo;t think I&rsquo;m brilliant and able to zoom into the issue
immediately all the time. The video is not recorded as I was going
through it the first time, so I exactly knew where I was going and
which steps to take.</p>

<p>If you want to look up some more information on GDB that I&rsquo;m using
in the video, here are some links that explain some of the most
used commands in the video:</p>

<p><a href="http://sourceware.org/gdb/onlinedocs/gdb/Data.html">GDB - Examining data</a>
<a href="http://sourceware.org/gdb/onlinedocs/gdb/Set-Watchpoints.html">GDB - Setting watchpoints</a></p>

<p>During the video there&rsquo;s a part from 8:18 until 11:28 where it&rsquo;s just
watching a rebuild of Rubinius scrolling by. I&rsquo;d suggest skipping it
since it&rsquo;s not very useful. I tried to remove it but after having
to reencode the video it only grew larger. If anyone has more skills
to fix that, please let us know!</p>

<h3 id="download">Download</h3>

<p>You can find the video on Vimeo:</p>

<p><a href="http://vimeo.com/34622441">Watch on Vimeo</a></p>

<p>It&rsquo;s probably best to download the video and play it locally on your
machine. It&rsquo;s 453 MB so it might take a while.</p>

<p>Please let us know if you find this useful, we might do more of them
in the future if there&rsquo;s interest!</p>


    </div>
  
    <div class="post">
      <h2 class="post_title">
        <a href="/2011/10/18/contributing-to-rubinius/" title="Contributing to Rubinius" class="post_title">
        Contributing to Rubinius
        </a>
      </h2>
      <div class="by_line">
  <p><span class="author">Brian Ford</span>
    <span class="date">18 October 2011</span>
    
      <a href="http://rubini.us/2011/10/18/contributing-to-rubinius/#disqus_thread" data-disqus-identifier="/2011/10/18/contributing-to-rubinius/"></a>

    
  </p>
</div>

      <p>Implementing Ruby is a lot of hard work. The Rubinius project has been lucky
to have <a href="http://it.isagit.com/rubinius/rubinius">more than 240 contributors</a>,
many with <em>hundreds</em> of commits, including code, benchmarks, documentation,
translations, and more. Lately, we have seen a surge of new folks working hard
on 1.9 language features. While we concentrate on making Rubinius easy to
contribute to, this post should clarify some things and pave an easier road to
your first Rubinius commit.</p>

<h3 id="contributions">Contributions</h3>

<p>Before diving into the Rubinius code, I want to emphasize that there are many
ways that you can contribute to Rubinius. One of the most valuable for us is
trying your own library or application on Rubinius. We&rsquo;ve worked super hard to
make using Rubinius in place of MRI as simple as possible. For example, with a
typical Rails application, here is all you should need to do to get set up:</p>

<pre><code>rvm install rbx
rvm use rbx
gem install bundler
</code></pre>

<p>Once you&rsquo;ve got Rubinius and Bundler installed, running your application
should be this simple:</p>

<pre><code>cd &lt;my_application&gt;
rm Gemfile.lock
bundle install
</code></pre>

<p>Note the step of removing the <code>Gemfile.lock</code>. This is necessary to force
bundler to resolve the dependencies for Rubinius. This is very important. Not
all gems for MRI will work with Rubinius, and in some cases Rubinius has
built-in gems or stubs that need to be considered when resolving dependencies
(ruby-debug and ffi are two examples).</p>

<p>Once <code>bundle install</code> is finished, you should be able to start your
application just like you would under MRI. If you have any trouble, please let
us know. Issues for Rubinius are <a href="https://github.com/rubinius/rubinius/issues">tracked on
Github</a>.</p>

<p>Another way to contribute to Rubinius is talking about the project. If you
tried your application and your 50 gems installed without problems, consider
<a href="https://twitter.com/rubinius">tweeting at us</a> or writing up a quick blog post
about your experiences. If you&rsquo;ve done something
<a href="http://fancy-lang.org/">fancy</a> that you&rsquo;d like to share with us, we&rsquo;re always
happy to have <a href="http://rubini.us/2011/02/23/introduction-to-fancy/">guest blog
posts</a>, too. We even have
documentation on <a href="http://rubini.us/doc/en/how-to/write-a-blog-post/">how to write a blog
post</a>.</p>

<h3 id="clone--build">Clone &amp; Build</h3>

<p>Before we can do anything else, we need to get the Rubinius source code and
build it. Run the commands below to do this:</p>

<pre><code>git clone git://github.com/rubinius/rubinius.git
cd rubinius
./configure
rake
</code></pre>

<p>You can run Rubinius directly from the build directory, there is no need to
install it. We provide symlinks for common commands like <code>gem</code>, <code>rake</code>, <code>irb</code>,
<code>ri</code>, <code>rdoc</code>, and even <code>ruby</code>. Just add <code>&lt;rbx_clone&gt;/bin</code> to your <code>PATH</code>.</p>

<p>If you run into any trouble with these steps, see the <a href="http://rubini.us/doc/en/getting-started/">Getting
Started</a> page for more information.
You may need to install libraries required to build Rubinius. If you don&rsquo;t
find answers there, visit the <code>#rubinius</code> channel on freenode.net and we&rsquo;ll
help you out.</p>

<p>While the build is running, let&rsquo;s get a quick overview of how Rubinius is
organized.</p>

<h3 id="code-tour">Code Tour</h3>

<p>There are two main divisions in the Rubinius source code. The virtual machine,
garbage collector, and just-in-time (JIT) compiler are written in C++. The
Ruby core library, bytecode compiler, and various tools like the profiler and
debugger are written mostly or all in Ruby.</p>

<h4 id="ruby-core-library">Ruby Core Library</h4>

<p>The Ruby core library is found in the <code>kernel/</code> directory. The kernel is
divided into subdirectories that are loaded in order when Rubinius boots. The
divisions were made to help share the Ruby core library with other
implementations. I&rsquo;ll cover those basic divisions here. For more details about
how the loading process works, see the
<a href="http://rubini.us/doc/en/bootstrapping/">Bootstrapping</a> documentation.</p>

<ol>
  <li><code>alpha.rb</code> - Sets up very basic Ruby features needed to start loading the
rest of the core library.</li>
  <li><code>bootstrap/</code>- Contains implementation-specific features needed to load the
main parts of the core library.</li>
  <li><code>platform/</code> - Contains platform-specific features like the FFI
(foreign-function interface) code that is used extensively in Rubinius to
bind to standard <code>libc</code> functions.</li>
  <li><code>common/</code> - Contains the majority of the Ruby core library and the code
should be implementation-agnostic.</li>
  <li><code>delta/</code> - Contains more implementation-specific code that may extend or
override code from <code>common/</code>.</li>
</ol>

<p>Most of the work on the Ruby core library will be done in <code>kernel/common/</code>.</p>

<h4 id="rubinius-vm">Rubinius VM</h4>

<p>The concept of a virtual machine is somewhat nebulous. It can be hard to draw
the lines around the different components. In Rubinius, the code for the
bytecode interpreter, garbage collector, and JIT compiler is under the <code>vm/</code>
directory. There are subdirectories for the garbage collector (<code>vm/gc/</code>) and
the JIT compiler (<code>vm/llvm/</code>). The <code>main()</code> function is in
<code>vm/drivers/cli.cpp</code>.</p>

<p>One of the important parts of Rubinius are the low-level operations that
cannot be defined in Ruby. These are things like adding two Fixnums together.
These operations are called primitives and the code for them is in
<code>vm/builtin</code>. Since you will likely encounter these in the core library, we&rsquo;ll
delve into them a bit.</p>

<h4 id="primitives">Primitives</h4>

<p>All methods that can be called in Ruby are exposed as, well, Ruby methods. If
you open <code>kernel/bootstrap/fixnum.rb</code>, you should see the following code:</p>

<div class="highlight"><pre><code class="ruby"><span class="lineno">1</span> <span class="k">def</span> <span class="nf">to_f</span>
<span class="lineno">2</span>   <span class="no">Rubinius</span><span class="o">.</span><span class="n">primitive</span> <span class="ss">:fixnum_to_f</span>
<span class="lineno">3</span>   <span class="k">raise</span> <span class="no">PrimitiveFailure</span><span class="p">,</span> <span class="s2">&quot;Fixnum#to_f primitive failed&quot;</span>
<span class="lineno">4</span> <span class="k">end</span>
</code></pre>
</div>

<p>The <code>Rubinius.primitive :fixnum_to_f</code> code looks like a normal Ruby method
call but it is not. It&rsquo;s actually a compiler directive to tag this Ruby method
as having an associated primitive operation. The name of the primitive is
<code>fixnum_to_f</code>. This naming convention is standard, being composed of the class
name and the method name. Methods in Ruby that are characters, like <code>+</code>, are
given word names for the primitives.</p>

<p>When this method is run, the primitive operation is invoked. If the primitive
operation fails, the Ruby code following the <code>Rubinius.primitive</code> line is run.
This code can perform any Ruby operation. For example, it may coerce the
arguments to a particular class and re-dispatch to itself. If no other
operation is appropriate, the method should raise an exception.</p>

<p>To see how the Ruby method relates to the primitive code, open
<code>vm/builtin/fixnum.hpp</code>:</p>

<div class="highlight"><pre><code class="cpp"><span class="lineno">1</span> <span class="c1">// Rubinius.primitive :fixnum_to_f</span>
<span class="lineno">2</span> <span class="n">Float</span><span class="o">*</span> <span class="nf">to_f</span><span class="p">(</span><span class="n">STATE</span><span class="p">);</span>
</code></pre>
</div>

<p>The <code>vm/builtin/*.hpp</code> files are processed by the Rubinius build system to
automatically generate C++ code to resolve and bind these primitive
operations. The comment provides the link between the Ruby method and the C++
method.</p>

<p>Finally, the actual implementation of this primitive is found in
<code>vm/builtin/fixnum.cpp</code>:</p>

<div class="highlight"><pre><code class="cpp"><span class="lineno">1</span> <span class="n">Float</span><span class="o">*</span> <span class="n">Fixnum</span><span class="o">::</span><span class="n">to_f</span><span class="p">(</span><span class="n">STATE</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno">2</span>   <span class="k">return</span> <span class="n">Float</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">to_native</span><span class="p">());</span>
<span class="lineno">3</span> <span class="p">}</span>
</code></pre>
</div>

<p>Here you can see that a new Float object is being created from the value of
the Fixnum. Rubinius names the C++ classes that implement the Ruby primitive
operations the same as their Ruby counterparts. One of the goals of Rubinius
is to build an elegant, easily comprehensible system, and we feel that this
consistency has been a great benefit toward that goal.</p>

<p>Now that we have a basic idea of the structure of Rubinius, let&rsquo;s look at some
aspects of its runtime behavior, in particular, supporting different Ruby
language modes.</p>

<h3 id="language-modes">Language Modes</h3>

<p>Rubinius 2.0 (the master branch) implements both 1.8 and 1.9 language features
in one executable. You can select the language mode at runtime by passing the
<code>-X18</code> or <code>-X19</code> flag, either as a command line option or by setting the
<code>RBXOPT</code> environment variable. Both commands below should have the same
effect:</p>

<pre><code>RBXOPT=-X19 bin/rbx -v
bin/rbx -X19 -v
</code></pre>

<p>If I run that on my system, I will see the following:</p>

<pre><code>rubinius 2.0.0dev (1.9.2 0f223599 yyyy-mm-dd JI) [x86_64-apple-darwin10.8.0]
</code></pre>

<p>The default language mode is 1.8, so if you invoke <code>rbx</code> with no other
options, you&rsquo;ll be running in 1.8 mode. You can change the default mode with a
configure time option as follows:</p>

<pre><code>./configure --default-version=1.9
</code></pre>

<p>If you configure Rubinius to have a default language mode of 1.9, you can
access 1.8 mode with the <code>-X18</code> runtime option as discussed above.</p>

<p>Ok, we&rsquo;ve got the code, we understand something about how it is organized,
we&rsquo;ve got the runtime behavior down, now let&rsquo;s look at actually implementing
Ruby. To do that, we need to know how Ruby behaves, and that is what RubySpec
is all about.</p>

<h3 id="by-the-spec">By the Spec</h3>

<p>Rubinius created the RubySpec project to ensure that we would be faithfully
implementing Ruby behavior, and we are constantly contributing more to it.
Basically, Rubinius does it by the spec. So, any commit to the Ruby core
library in Rubinius must either have new specs or make existing specs pass. To
effectively contribute to Rubinius, you&rsquo;ll need to understand some basics
about RubySpec. I recommend that you have a read through the documentation at
<a href="http://rubyspec.org/">rubyspec.org</a>.</p>

<p>RubySpec includes a custom-built framework for the specs called MSpec. The
syntax is intended to be consistent with <a href="http://rspec.info">RSpec</a>, but there
are various facilities that are purpose-built to support multiple
implementations, multiple versions of Ruby, and multiple platforms.</p>

<h4 id="running-specs">Running Specs</h4>

<p>MSpec provides several different scripts to run the specs under different
conditions. The default behavior is to simply run all the specs. If you invoke
the following command, it will run all the Ruby Array specs in the default
language mode, which should be 1.8 unless you configured 1.9 to be the
default:</p>

<pre><code>bin/mspec core/array
</code></pre>

<p>To Run the specs in 1.9 mode, add the <code>-tx19</code> option:</p>

<pre><code>bin/mspec -tx19 core/array
</code></pre>

<p>The <code>-t</code> option specifies which target to run the specs under. The default in
Rubinius is to run them with Rubinius, so <code>-tx</code> is implied. You can easily run
with another target by giving the name of an executable on your PATH or the
full path to an executable. Since the specs are intended to show the behavior
of MRI, if you are writing new specs you need to run them under MRI 1.8.7 and
1.9.2. I have those on my PATH, so I can do the following:</p>

<pre><code>bin/mspec -t ruby1.8.7 core/array
bin/mspec -t ruby1.9.2 core/array
</code></pre>

<p>Finally, if you are running <code>bin/mspec</code> in the Rubinius source directory, the
location of the RubySpecs are known (<code>spec/ruby/</code>), so you can use the full
path or the shortened version <code>core/array</code> above.</p>

<h4 id="continuous-integration">Continuous Integration</h4>

<p>One goal of MSpec is to make it as easy as possible to run the specs for the
parts of Ruby that have been implemented. It takes a long time to implement
all of Ruby correctly, but we want to know that the parts we have implemented
don&rsquo;t get broken while working on other parts. That is the role of continuous
integration. To use CI effectively, we need to partition the specs into those
that we expect to pass and those we know we don&rsquo;t pass yet. MSpec provides a
facility for this, called tagging, that we&rsquo;ll look at shortly. For now, we&rsquo;ll
just look at running the specs in CI mode.</p>

<p>To run all the Rubinius specs in CI mode under the default language version,
use the following command:</p>

<pre><code>bin/mspec ci
</code></pre>

<p>Likewise, to run these specs in the 1.9 language mode, add the <code>-tx19</code> option:</p>

<pre><code>bin/mspec ci -tx19
</code></pre>

<p>The <code>bin/mspec ci</code> command runs the <code>mspec-ci</code> script. You should be familiar
with this mechanism from working with Git. It&rsquo;s the same idea. The <code>mspec</code>
script itself is just a utility to invoke the various specific MSpec scripts.
To see the options for <code>mspec</code>, run the following command</p>

<pre><code>bin/mspec -h
</code></pre>

<p>There are three basic functions that MSpec performs and these correspond to
<code>mspec-run</code>, <code>mspec-ci</code>, and <code>mspec-tag</code>. When not given an operation, <code>mspec</code>
assumes <code>run</code>, so the following two commands are equivalent:</p>

<pre><code>mspec core/array
mspec run core/array
</code></pre>

<p>If the operation is given, it must be the first parameter to <code>mspec</code>. In the
case below, the first command runs <code>mspec-ci</code> with <code>core/array</code> while the
second command runs <code>mspec-run</code> with <code>core/array</code> and <code>ci</code> as files.</p>

<pre><code>mspec ci core/array
mspec core/array ci
</code></pre>

<p>Now that we&rsquo;ve got the basics of MSpec down, let&rsquo;s look at how we find specs
that fail on Rubinius. To do this, we&rsquo;ll use the <code>mspec tag</code> command.</p>

<h4 id="tagged-specs">Tagged Specs</h4>

<p>Since Rubinius uses the tagging mechanism to create the set of CI specs to
run, the best way to discover what parts of RubySpec that Rubinius isn&rsquo;t
passing yet is to list the specs that are tagged. There&rsquo;s a command for that:</p>

<pre><code>bin/mspec tag --list fails -tx19 :ci_files
</code></pre>

<p>This command lists all the specs that are tagged as failing. There&rsquo;s some new
syntax here, namely <code>:ci_files</code>. MSpec has the concept of pseudo-directories.
Basically, they are lists of files. The reason for this is that running all
the core or standard library specs in RubySpec is not as simple as just
running all the files under <code>spec/ruby/core</code> or <code>spec/ruby/library</code>. It&rsquo;s more
complicated than that because there are 1.8- and 1.9-specific libraries.
Rather than wrapping everything in <code>ruby_version_is</code> guards, MSpec adds
version-specific lists and names them, for example, <code>:core</code> and <code>:library</code>.</p>

<p>In this case, we&rsquo;re using the list of files specified by <code>:ci_files</code>. This
list excludes some files that are known to cause problems if they are run.</p>

<p>The list of specs that are currently marked as failing is pretty long. We can
reduce the number of tags we are looking at by giving a smaller set of specs
to run.  For example, let&rsquo;s just run the File specs:</p>

<pre><code>bin/mspec tag --list fails -tx19 core/file
</code></pre>

<p>Looking at the output from this command, we notice (at least at the time of
writing this post) that there are several failures in the
<code>File.world_writable?</code> specs. We can run just these specs:</p>

<pre><code>bin/mspec tag --list fails -tx19 core/file/world_writable
</code></pre>

<p>If we look into the documentation for <code>File.world_writable?</code>, we&rsquo;ll find that
it is a new method introduced in 1.9. Excellent, this gives us an opportunity
to talk about language-specific changes in Rubinius.</p>

<h3 id="language-specific-changes">Language-specific Changes</h3>

<p>When Rubinius boots, it loads different files depending on what language mode
it is running. In the <code>kernel/**/</code> directories, there are <code>load_order18.txt</code>
and <code>load_order19.txt</code> files. These files are used during the build process to
create separate runtime kernels for Rubinius. You can see these in the
<code>runtime/18</code> and <code>runtime/19</code> directories after building.</p>

<p>Here&rsquo;s how language-specific features are handled in the Rubinius kernel.</p>

<ol>
  <li>If there are no language-specific methods, the name of the file in
<code>kernel/common</code> is the name of the class. In the case here, the file is
<code>kernel/common/file.rb</code>. This rule applies regardless of whether the class
is 1.8- or 1.9-specific. For example, Rational is part of the 1.9 core
library, but does not exist in the core library in 1.8. The Rational class
is in <code>kernel/core/rational.rb</code>.</li>
  <li>If there are version-specific methods, they go in <code>kernel/common/file18.rb</code>
and <code>kernel/common/file19.rb</code>. The correct file is then added to the
appropriate <code>load_orderNN.txt</code> file.</li>
</ol>

<p>In the case of <code>File.world_writable?</code>, there is no 1.8 version. So, we open
<code>kernel/common/file19.rb</code> and add the method definition. After changing any of
the <code>kernel/**/*.rb</code> files, we have to build Rubinius. Run the following
command to do that:</p>

<pre><code>rake build
</code></pre>

<p>After making the change, we verify that the specs pass by running the specs
<em>without</em> the CI tags:</p>

<pre><code>bin/mspec -tx19 core/file/world_writable
</code></pre>

<p>If all the specs pass, then you&rsquo;re ready to remove the CI tags. To do so, run
the following command:</p>

<pre><code>bin/mspec tag --del fails -tx19 core/file/world_writable
</code></pre>

<p>After removing the CI tags, the final step is to ensure that all specs still
pass. To run all the CI specs in both 1.8 and 1.9 modes, simply do:</p>

<pre><code>rake
</code></pre>

<p>If everything passes, you&rsquo;re ready to submit a pull request. All in all, that
wasn&rsquo;t too bad, right?</p>

<p>One final note, if you are making changes to RubySpec, make separate commits
in your pull request for changes to <code>spec/ruby/**/*_specs.rb</code> and another
commit for any other Rubinius files. It is fine to commit the removed tags
with the other Rubinius changes.</p>

<h3 id="wrapping-presents">Wrapping Presents</h3>

<p>The information here should give you everything you need to get your feet wet
in Rubinius. By the way, today is Evan&rsquo;s birthday. If you&rsquo;re not taking him to
dinner, why don&rsquo;t you show your appreciation for this fantastic project he
created by grabbing Rubinius and hacking on some Ruby code. Be safe and have
fun! We can&rsquo;t wait to hear from you.</p>

    </div>
  
  </div>

<footer>
  <div class='container'>
    <nav>
      <ul>
        <li><a rel="external" href="http://twitter.com/rubinius">Follow Rubinius on Twitter</a></li>
        <li><a rel="external" href="http://github.com/rubinius/rubinius">Fork Rubinius on github</a></li>
        <li><a rel="external" href="http://engineyard.com">An Engine Yard project</a></li>
      </ul>
    </nav>
  </div>
</footer>

<script>
  var _gaq=[['_setAccount','UA-12328521-1'],['_trackPageview']];
  (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];g.async=1;
  g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
  s.parentNode.insertBefore(g,s)}(document,'script'));
</script>


<script>
  var disqus_shortname = 'rubinius';
  
  (function () {
    var s = document.createElement('script'); s.async = true;
    s.type = 'text/javascript';
    s.src = 'http://' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
  }());
</script>

  </body>
</html>
